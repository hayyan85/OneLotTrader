// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rtypes.proto

#ifndef PROTOBUF_rtypes_2eproto__INCLUDED
#define PROTOBUF_rtypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Serializable {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rtypes_2eproto();
void protobuf_AssignDesc_rtypes_2eproto();
void protobuf_ShutdownFile_rtypes_2eproto();

class CustROrder_ser;
class ROrderPosition;
class TradeUpdate;
class RUpdatePacket;
class ExtraRFields;

enum CustROrder_ser_EPriceType {
  CustROrder_ser_EPriceType_Lmt = 0
};
bool CustROrder_ser_EPriceType_IsValid(int value);
const CustROrder_ser_EPriceType CustROrder_ser_EPriceType_EPriceType_MIN = CustROrder_ser_EPriceType_Lmt;
const CustROrder_ser_EPriceType CustROrder_ser_EPriceType_EPriceType_MAX = CustROrder_ser_EPriceType_Lmt;
const int CustROrder_ser_EPriceType_EPriceType_ARRAYSIZE = CustROrder_ser_EPriceType_EPriceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CustROrder_ser_EPriceType_descriptor();
inline const ::std::string& CustROrder_ser_EPriceType_Name(CustROrder_ser_EPriceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CustROrder_ser_EPriceType_descriptor(), value);
}
inline bool CustROrder_ser_EPriceType_Parse(
    const ::std::string& name, CustROrder_ser_EPriceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CustROrder_ser_EPriceType>(
    CustROrder_ser_EPriceType_descriptor(), name, value);
}
// ===================================================================

class CustROrder_ser : public ::google::protobuf::Message {
 public:
  CustROrder_ser();
  virtual ~CustROrder_ser();

  CustROrder_ser(const CustROrder_ser& from);

  inline CustROrder_ser& operator=(const CustROrder_ser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustROrder_ser& default_instance();

  void Swap(CustROrder_ser* other);

  // implements Message ----------------------------------------------

  CustROrder_ser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CustROrder_ser& from);
  void MergeFrom(const CustROrder_ser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef CustROrder_ser_EPriceType EPriceType;
  static const EPriceType Lmt = CustROrder_ser_EPriceType_Lmt;
  static inline bool EPriceType_IsValid(int value) {
    return CustROrder_ser_EPriceType_IsValid(value);
  }
  static const EPriceType EPriceType_MIN =
    CustROrder_ser_EPriceType_EPriceType_MIN;
  static const EPriceType EPriceType_MAX =
    CustROrder_ser_EPriceType_EPriceType_MAX;
  static const int EPriceType_ARRAYSIZE =
    CustROrder_ser_EPriceType_EPriceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EPriceType_descriptor() {
    return CustROrder_ser_EPriceType_descriptor();
  }
  static inline const ::std::string& EPriceType_Name(EPriceType value) {
    return CustROrder_ser_EPriceType_Name(value);
  }
  static inline bool EPriceType_Parse(const ::std::string& name,
      EPriceType* value) {
    return CustROrder_ser_EPriceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string bstrAccount = 1;
  inline bool has_bstraccount() const;
  inline void clear_bstraccount();
  static const int kBstrAccountFieldNumber = 1;
  inline const ::std::string& bstraccount() const;
  inline void set_bstraccount(const ::std::string& value);
  inline void set_bstraccount(const char* value);
  inline void set_bstraccount(const char* value, size_t size);
  inline ::std::string* mutable_bstraccount();
  inline ::std::string* release_bstraccount();
  inline void set_allocated_bstraccount(::std::string* bstraccount);

  // optional string bstrDestination = 2;
  inline bool has_bstrdestination() const;
  inline void clear_bstrdestination();
  static const int kBstrDestinationFieldNumber = 2;
  inline const ::std::string& bstrdestination() const;
  inline void set_bstrdestination(const ::std::string& value);
  inline void set_bstrdestination(const char* value);
  inline void set_bstrdestination(const char* value, size_t size);
  inline ::std::string* mutable_bstrdestination();
  inline ::std::string* release_bstrdestination();
  inline void set_allocated_bstrdestination(::std::string* bstrdestination);

  // optional int32 nOrderStatus = 3;
  inline bool has_norderstatus() const;
  inline void clear_norderstatus();
  static const int kNOrderStatusFieldNumber = 3;
  inline ::google::protobuf::int32 norderstatus() const;
  inline void set_norderstatus(::google::protobuf::int32 value);

  // optional string bstrSymbol = 4;
  inline bool has_bstrsymbol() const;
  inline void clear_bstrsymbol();
  static const int kBstrSymbolFieldNumber = 4;
  inline const ::std::string& bstrsymbol() const;
  inline void set_bstrsymbol(const ::std::string& value);
  inline void set_bstrsymbol(const char* value);
  inline void set_bstrsymbol(const char* value, size_t size);
  inline ::std::string* mutable_bstrsymbol();
  inline ::std::string* release_bstrsymbol();
  inline void set_allocated_bstrsymbol(::std::string* bstrsymbol);

  // optional string bstrClOrderId = 5;
  inline bool has_bstrclorderid() const;
  inline void clear_bstrclorderid();
  static const int kBstrClOrderIdFieldNumber = 5;
  inline const ::std::string& bstrclorderid() const;
  inline void set_bstrclorderid(const ::std::string& value);
  inline void set_bstrclorderid(const char* value);
  inline void set_bstrclorderid(const char* value, size_t size);
  inline ::std::string* mutable_bstrclorderid();
  inline ::std::string* release_bstrclorderid();
  inline void set_allocated_bstrclorderid(::std::string* bstrclorderid);

  // optional string bstrAction = 6;
  inline bool has_bstraction() const;
  inline void clear_bstraction();
  static const int kBstrActionFieldNumber = 6;
  inline const ::std::string& bstraction() const;
  inline void set_bstraction(const ::std::string& value);
  inline void set_bstraction(const char* value);
  inline void set_bstraction(const char* value, size_t size);
  inline ::std::string* mutable_bstraction();
  inline ::std::string* release_bstraction();
  inline void set_allocated_bstraction(::std::string* bstraction);

  // optional string Side = 7;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 7;
  inline const ::std::string& side() const;
  inline void set_side(const ::std::string& value);
  inline void set_side(const char* value);
  inline void set_side(const char* value, size_t size);
  inline ::std::string* mutable_side();
  inline ::std::string* release_side();
  inline void set_allocated_side(::std::string* side);

  // optional int32 nQuantity = 8;
  inline bool has_nquantity() const;
  inline void clear_nquantity();
  static const int kNQuantityFieldNumber = 8;
  inline ::google::protobuf::int32 nquantity() const;
  inline void set_nquantity(::google::protobuf::int32 value);

  // optional int32 nLvsQuantity = 9;
  inline bool has_nlvsquantity() const;
  inline void clear_nlvsquantity();
  static const int kNLvsQuantityFieldNumber = 9;
  inline ::google::protobuf::int32 nlvsquantity() const;
  inline void set_nlvsquantity(::google::protobuf::int32 value);

  // optional string bstrLogMessage = 10;
  inline bool has_bstrlogmessage() const;
  inline void clear_bstrlogmessage();
  static const int kBstrLogMessageFieldNumber = 10;
  inline const ::std::string& bstrlogmessage() const;
  inline void set_bstrlogmessage(const ::std::string& value);
  inline void set_bstrlogmessage(const char* value);
  inline void set_bstrlogmessage(const char* value, size_t size);
  inline ::std::string* mutable_bstrlogmessage();
  inline ::std::string* release_bstrlogmessage();
  inline void set_allocated_bstrlogmessage(::std::string* bstrlogmessage);

  // optional float LmtPrice = 11;
  inline bool has_lmtprice() const;
  inline void clear_lmtprice();
  static const int kLmtPriceFieldNumber = 11;
  inline float lmtprice() const;
  inline void set_lmtprice(float value);

  // optional string bstrUser = 12;
  inline bool has_bstruser() const;
  inline void clear_bstruser();
  static const int kBstrUserFieldNumber = 12;
  inline const ::std::string& bstruser() const;
  inline void set_bstruser(const ::std::string& value);
  inline void set_bstruser(const char* value);
  inline void set_bstruser(const char* value, size_t size);
  inline ::std::string* mutable_bstruser();
  inline ::std::string* release_bstruser();
  inline void set_allocated_bstruser(::std::string* bstruser);

  // optional int32 TotalExecutedQty = 13;
  inline bool has_totalexecutedqty() const;
  inline void clear_totalexecutedqty();
  static const int kTotalExecutedQtyFieldNumber = 13;
  inline ::google::protobuf::int32 totalexecutedqty() const;
  inline void set_totalexecutedqty(::google::protobuf::int32 value);

  // optional int32 ExecutedQty = 14;
  inline bool has_executedqty() const;
  inline void clear_executedqty();
  static const int kExecutedQtyFieldNumber = 14;
  inline ::google::protobuf::int32 executedqty() const;
  inline void set_executedqty(::google::protobuf::int32 value);

  // optional string cust_cancelOrderID = 15;
  inline bool has_cust_cancelorderid() const;
  inline void clear_cust_cancelorderid();
  static const int kCustCancelOrderIDFieldNumber = 15;
  inline const ::std::string& cust_cancelorderid() const;
  inline void set_cust_cancelorderid(const ::std::string& value);
  inline void set_cust_cancelorderid(const char* value);
  inline void set_cust_cancelorderid(const char* value, size_t size);
  inline ::std::string* mutable_cust_cancelorderid();
  inline ::std::string* release_cust_cancelorderid();
  inline void set_allocated_cust_cancelorderid(::std::string* cust_cancelorderid);

  // optional string cust_orderCategory = 16;
  inline bool has_cust_ordercategory() const;
  inline void clear_cust_ordercategory();
  static const int kCustOrderCategoryFieldNumber = 16;
  inline const ::std::string& cust_ordercategory() const;
  inline void set_cust_ordercategory(const ::std::string& value);
  inline void set_cust_ordercategory(const char* value);
  inline void set_cust_ordercategory(const char* value, size_t size);
  inline ::std::string* mutable_cust_ordercategory();
  inline ::std::string* release_cust_ordercategory();
  inline void set_allocated_cust_ordercategory(::std::string* cust_ordercategory);

  // optional .Serializable.CustROrder_ser.EPriceType PriceType = 17;
  inline bool has_pricetype() const;
  inline void clear_pricetype();
  static const int kPriceTypeFieldNumber = 17;
  inline ::Serializable::CustROrder_ser_EPriceType pricetype() const;
  inline void set_pricetype(::Serializable::CustROrder_ser_EPriceType value);

  // optional string TIF = 18;
  inline bool has_tif() const;
  inline void clear_tif();
  static const int kTIFFieldNumber = 18;
  inline const ::std::string& tif() const;
  inline void set_tif(const ::std::string& value);
  inline void set_tif(const char* value);
  inline void set_tif(const char* value, size_t size);
  inline ::std::string* mutable_tif();
  inline ::std::string* release_tif();
  inline void set_allocated_tif(::std::string* tif);

  // optional string DateTime = 19;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 19;
  inline const ::std::string& datetime() const;
  inline void set_datetime(const ::std::string& value);
  inline void set_datetime(const char* value);
  inline void set_datetime(const char* value, size_t size);
  inline ::std::string* mutable_datetime();
  inline ::std::string* release_datetime();
  inline void set_allocated_datetime(::std::string* datetime);

  // optional string strategy = 20;
  inline bool has_strategy() const;
  inline void clear_strategy();
  static const int kStrategyFieldNumber = 20;
  inline const ::std::string& strategy() const;
  inline void set_strategy(const ::std::string& value);
  inline void set_strategy(const char* value);
  inline void set_strategy(const char* value, size_t size);
  inline ::std::string* mutable_strategy();
  inline ::std::string* release_strategy();
  inline void set_allocated_strategy(::std::string* strategy);

  // optional string maturity = 22;
  inline bool has_maturity() const;
  inline void clear_maturity();
  static const int kMaturityFieldNumber = 22;
  inline const ::std::string& maturity() const;
  inline void set_maturity(const ::std::string& value);
  inline void set_maturity(const char* value);
  inline void set_maturity(const char* value, size_t size);
  inline ::std::string* mutable_maturity();
  inline ::std::string* release_maturity();
  inline void set_allocated_maturity(::std::string* maturity);

  // optional string putcall = 23;
  inline bool has_putcall() const;
  inline void clear_putcall();
  static const int kPutcallFieldNumber = 23;
  inline const ::std::string& putcall() const;
  inline void set_putcall(const ::std::string& value);
  inline void set_putcall(const char* value);
  inline void set_putcall(const char* value, size_t size);
  inline ::std::string* mutable_putcall();
  inline ::std::string* release_putcall();
  inline void set_allocated_putcall(::std::string* putcall);

  // optional string instrument = 24;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 24;
  inline const ::std::string& instrument() const;
  inline void set_instrument(const ::std::string& value);
  inline void set_instrument(const char* value);
  inline void set_instrument(const char* value, size_t size);
  inline ::std::string* mutable_instrument();
  inline ::std::string* release_instrument();
  inline void set_allocated_instrument(::std::string* instrument);

  // optional float strikeprice = 25;
  inline bool has_strikeprice() const;
  inline void clear_strikeprice();
  static const int kStrikepriceFieldNumber = 25;
  inline float strikeprice() const;
  inline void set_strikeprice(float value);

  // optional string underlying = 26;
  inline bool has_underlying() const;
  inline void clear_underlying();
  static const int kUnderlyingFieldNumber = 26;
  inline const ::std::string& underlying() const;
  inline void set_underlying(const ::std::string& value);
  inline void set_underlying(const char* value);
  inline void set_underlying(const char* value, size_t size);
  inline ::std::string* mutable_underlying();
  inline ::std::string* release_underlying();
  inline void set_allocated_underlying(::std::string* underlying);

  // optional string nOrderRecordId = 27;
  inline bool has_norderrecordid() const;
  inline void clear_norderrecordid();
  static const int kNOrderRecordIdFieldNumber = 27;
  inline const ::std::string& norderrecordid() const;
  inline void set_norderrecordid(const ::std::string& value);
  inline void set_norderrecordid(const char* value);
  inline void set_norderrecordid(const char* value, size_t size);
  inline ::std::string* mutable_norderrecordid();
  inline ::std::string* release_norderrecordid();
  inline void set_allocated_norderrecordid(::std::string* norderrecordid);

  // @@protoc_insertion_point(class_scope:Serializable.CustROrder_ser)
 private:
  inline void set_has_bstraccount();
  inline void clear_has_bstraccount();
  inline void set_has_bstrdestination();
  inline void clear_has_bstrdestination();
  inline void set_has_norderstatus();
  inline void clear_has_norderstatus();
  inline void set_has_bstrsymbol();
  inline void clear_has_bstrsymbol();
  inline void set_has_bstrclorderid();
  inline void clear_has_bstrclorderid();
  inline void set_has_bstraction();
  inline void clear_has_bstraction();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_nquantity();
  inline void clear_has_nquantity();
  inline void set_has_nlvsquantity();
  inline void clear_has_nlvsquantity();
  inline void set_has_bstrlogmessage();
  inline void clear_has_bstrlogmessage();
  inline void set_has_lmtprice();
  inline void clear_has_lmtprice();
  inline void set_has_bstruser();
  inline void clear_has_bstruser();
  inline void set_has_totalexecutedqty();
  inline void clear_has_totalexecutedqty();
  inline void set_has_executedqty();
  inline void clear_has_executedqty();
  inline void set_has_cust_cancelorderid();
  inline void clear_has_cust_cancelorderid();
  inline void set_has_cust_ordercategory();
  inline void clear_has_cust_ordercategory();
  inline void set_has_pricetype();
  inline void clear_has_pricetype();
  inline void set_has_tif();
  inline void clear_has_tif();
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_strategy();
  inline void clear_has_strategy();
  inline void set_has_maturity();
  inline void clear_has_maturity();
  inline void set_has_putcall();
  inline void clear_has_putcall();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_strikeprice();
  inline void clear_has_strikeprice();
  inline void set_has_underlying();
  inline void clear_has_underlying();
  inline void set_has_norderrecordid();
  inline void clear_has_norderrecordid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bstraccount_;
  ::std::string* bstrdestination_;
  ::std::string* bstrsymbol_;
  ::std::string* bstrclorderid_;
  ::google::protobuf::int32 norderstatus_;
  ::google::protobuf::int32 nquantity_;
  ::std::string* bstraction_;
  ::std::string* side_;
  ::std::string* bstrlogmessage_;
  ::google::protobuf::int32 nlvsquantity_;
  float lmtprice_;
  ::std::string* bstruser_;
  ::google::protobuf::int32 totalexecutedqty_;
  ::google::protobuf::int32 executedqty_;
  ::std::string* cust_cancelorderid_;
  ::std::string* cust_ordercategory_;
  ::std::string* tif_;
  ::std::string* datetime_;
  ::std::string* strategy_;
  int pricetype_;
  float strikeprice_;
  ::std::string* maturity_;
  ::std::string* putcall_;
  ::std::string* instrument_;
  ::std::string* underlying_;
  ::std::string* norderrecordid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  friend void  protobuf_AddDesc_rtypes_2eproto();
  friend void protobuf_AssignDesc_rtypes_2eproto();
  friend void protobuf_ShutdownFile_rtypes_2eproto();

  void InitAsDefaultInstance();
  static CustROrder_ser* default_instance_;
};
// -------------------------------------------------------------------

class ROrderPosition : public ::google::protobuf::Message {
 public:
  ROrderPosition();
  virtual ~ROrderPosition();

  ROrderPosition(const ROrderPosition& from);

  inline ROrderPosition& operator=(const ROrderPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ROrderPosition& default_instance();

  void Swap(ROrderPosition* other);

  // implements Message ----------------------------------------------

  ROrderPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ROrderPosition& from);
  void MergeFrom(const ROrderPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline ::google::protobuf::int32 position() const;
  inline void set_position(::google::protobuf::int32 value);

  // optional float execution_price = 2;
  inline bool has_execution_price() const;
  inline void clear_execution_price();
  static const int kExecutionPriceFieldNumber = 2;
  inline float execution_price() const;
  inline void set_execution_price(float value);

  // @@protoc_insertion_point(class_scope:Serializable.ROrderPosition)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_execution_price();
  inline void clear_has_execution_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 position_;
  float execution_price_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rtypes_2eproto();
  friend void protobuf_AssignDesc_rtypes_2eproto();
  friend void protobuf_ShutdownFile_rtypes_2eproto();

  void InitAsDefaultInstance();
  static ROrderPosition* default_instance_;
};
// -------------------------------------------------------------------

class TradeUpdate : public ::google::protobuf::Message {
 public:
  TradeUpdate();
  virtual ~TradeUpdate();

  TradeUpdate(const TradeUpdate& from);

  inline TradeUpdate& operator=(const TradeUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeUpdate& default_instance();

  void Swap(TradeUpdate* other);

  // implements Message ----------------------------------------------

  TradeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradeUpdate& from);
  void MergeFrom(const TradeUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string symbol = 1;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 1;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string client_id = 2;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 2;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const char* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // optional string side = 3;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 3;
  inline const ::std::string& side() const;
  inline void set_side(const ::std::string& value);
  inline void set_side(const char* value);
  inline void set_side(const char* value, size_t size);
  inline ::std::string* mutable_side();
  inline ::std::string* release_side();
  inline void set_allocated_side(::std::string* side);

  // optional int32 volume = 4;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 4;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);

  // optional float exec_price = 5;
  inline bool has_exec_price() const;
  inline void clear_exec_price();
  static const int kExecPriceFieldNumber = 5;
  inline float exec_price() const;
  inline void set_exec_price(float value);

  // optional string DateTimetime = 6;
  inline bool has_datetimetime() const;
  inline void clear_datetimetime();
  static const int kDateTimetimeFieldNumber = 6;
  inline const ::std::string& datetimetime() const;
  inline void set_datetimetime(const ::std::string& value);
  inline void set_datetimetime(const char* value);
  inline void set_datetimetime(const char* value, size_t size);
  inline ::std::string* mutable_datetimetime();
  inline ::std::string* release_datetimetime();
  inline void set_allocated_datetimetime(::std::string* datetimetime);

  // @@protoc_insertion_point(class_scope:Serializable.TradeUpdate)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_exec_price();
  inline void clear_has_exec_price();
  inline void set_has_datetimetime();
  inline void clear_has_datetimetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* symbol_;
  ::std::string* client_id_;
  ::std::string* side_;
  ::google::protobuf::int32 volume_;
  float exec_price_;
  ::std::string* datetimetime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_rtypes_2eproto();
  friend void protobuf_AssignDesc_rtypes_2eproto();
  friend void protobuf_ShutdownFile_rtypes_2eproto();

  void InitAsDefaultInstance();
  static TradeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class RUpdatePacket : public ::google::protobuf::Message {
 public:
  RUpdatePacket();
  virtual ~RUpdatePacket();

  RUpdatePacket(const RUpdatePacket& from);

  inline RUpdatePacket& operator=(const RUpdatePacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RUpdatePacket& default_instance();

  void Swap(RUpdatePacket* other);

  // implements Message ----------------------------------------------

  RUpdatePacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RUpdatePacket& from);
  void MergeFrom(const RUpdatePacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Serializable.CustROrder_ser custOrd = 1;
  inline bool has_custord() const;
  inline void clear_custord();
  static const int kCustOrdFieldNumber = 1;
  inline const ::Serializable::CustROrder_ser& custord() const;
  inline ::Serializable::CustROrder_ser* mutable_custord();
  inline ::Serializable::CustROrder_ser* release_custord();
  inline void set_allocated_custord(::Serializable::CustROrder_ser* custord);

  // optional .Serializable.ROrderPosition pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline const ::Serializable::ROrderPosition& pos() const;
  inline ::Serializable::ROrderPosition* mutable_pos();
  inline ::Serializable::ROrderPosition* release_pos();
  inline void set_allocated_pos(::Serializable::ROrderPosition* pos);

  // optional .Serializable.TradeUpdate tupdate = 3;
  inline bool has_tupdate() const;
  inline void clear_tupdate();
  static const int kTupdateFieldNumber = 3;
  inline const ::Serializable::TradeUpdate& tupdate() const;
  inline ::Serializable::TradeUpdate* mutable_tupdate();
  inline ::Serializable::TradeUpdate* release_tupdate();
  inline void set_allocated_tupdate(::Serializable::TradeUpdate* tupdate);

  // @@protoc_insertion_point(class_scope:Serializable.RUpdatePacket)
 private:
  inline void set_has_custord();
  inline void clear_has_custord();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_tupdate();
  inline void clear_has_tupdate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Serializable::CustROrder_ser* custord_;
  ::Serializable::ROrderPosition* pos_;
  ::Serializable::TradeUpdate* tupdate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_rtypes_2eproto();
  friend void protobuf_AssignDesc_rtypes_2eproto();
  friend void protobuf_ShutdownFile_rtypes_2eproto();

  void InitAsDefaultInstance();
  static RUpdatePacket* default_instance_;
};
// -------------------------------------------------------------------

class ExtraRFields : public ::google::protobuf::Message {
 public:
  ExtraRFields();
  virtual ~ExtraRFields();

  ExtraRFields(const ExtraRFields& from);

  inline ExtraRFields& operator=(const ExtraRFields& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtraRFields& default_instance();

  void Swap(ExtraRFields* other);

  // implements Message ----------------------------------------------

  ExtraRFields* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExtraRFields& from);
  void MergeFrom(const ExtraRFields& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string FormID = 1;
  inline bool has_formid() const;
  inline void clear_formid();
  static const int kFormIDFieldNumber = 1;
  inline const ::std::string& formid() const;
  inline void set_formid(const ::std::string& value);
  inline void set_formid(const char* value);
  inline void set_formid(const char* value, size_t size);
  inline ::std::string* mutable_formid();
  inline ::std::string* release_formid();
  inline void set_allocated_formid(::std::string* formid);

  // optional string OrderType = 2;
  inline bool has_ordertype() const;
  inline void clear_ordertype();
  static const int kOrderTypeFieldNumber = 2;
  inline const ::std::string& ordertype() const;
  inline void set_ordertype(const ::std::string& value);
  inline void set_ordertype(const char* value);
  inline void set_ordertype(const char* value, size_t size);
  inline ::std::string* mutable_ordertype();
  inline ::std::string* release_ordertype();
  inline void set_allocated_ordertype(::std::string* ordertype);

  // @@protoc_insertion_point(class_scope:Serializable.ExtraRFields)
 private:
  inline void set_has_formid();
  inline void clear_has_formid();
  inline void set_has_ordertype();
  inline void clear_has_ordertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* formid_;
  ::std::string* ordertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rtypes_2eproto();
  friend void protobuf_AssignDesc_rtypes_2eproto();
  friend void protobuf_ShutdownFile_rtypes_2eproto();

  void InitAsDefaultInstance();
  static ExtraRFields* default_instance_;
};
// ===================================================================


// ===================================================================

// CustROrder_ser

// optional string bstrAccount = 1;
inline bool CustROrder_ser::has_bstraccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustROrder_ser::set_has_bstraccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CustROrder_ser::clear_has_bstraccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CustROrder_ser::clear_bstraccount() {
  if (bstraccount_ != &::google::protobuf::internal::kEmptyString) {
    bstraccount_->clear();
  }
  clear_has_bstraccount();
}
inline const ::std::string& CustROrder_ser::bstraccount() const {
  return *bstraccount_;
}
inline void CustROrder_ser::set_bstraccount(const ::std::string& value) {
  set_has_bstraccount();
  if (bstraccount_ == &::google::protobuf::internal::kEmptyString) {
    bstraccount_ = new ::std::string;
  }
  bstraccount_->assign(value);
}
inline void CustROrder_ser::set_bstraccount(const char* value) {
  set_has_bstraccount();
  if (bstraccount_ == &::google::protobuf::internal::kEmptyString) {
    bstraccount_ = new ::std::string;
  }
  bstraccount_->assign(value);
}
inline void CustROrder_ser::set_bstraccount(const char* value, size_t size) {
  set_has_bstraccount();
  if (bstraccount_ == &::google::protobuf::internal::kEmptyString) {
    bstraccount_ = new ::std::string;
  }
  bstraccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_bstraccount() {
  set_has_bstraccount();
  if (bstraccount_ == &::google::protobuf::internal::kEmptyString) {
    bstraccount_ = new ::std::string;
  }
  return bstraccount_;
}
inline ::std::string* CustROrder_ser::release_bstraccount() {
  clear_has_bstraccount();
  if (bstraccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bstraccount_;
    bstraccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_bstraccount(::std::string* bstraccount) {
  if (bstraccount_ != &::google::protobuf::internal::kEmptyString) {
    delete bstraccount_;
  }
  if (bstraccount) {
    set_has_bstraccount();
    bstraccount_ = bstraccount;
  } else {
    clear_has_bstraccount();
    bstraccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bstrDestination = 2;
inline bool CustROrder_ser::has_bstrdestination() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CustROrder_ser::set_has_bstrdestination() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CustROrder_ser::clear_has_bstrdestination() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CustROrder_ser::clear_bstrdestination() {
  if (bstrdestination_ != &::google::protobuf::internal::kEmptyString) {
    bstrdestination_->clear();
  }
  clear_has_bstrdestination();
}
inline const ::std::string& CustROrder_ser::bstrdestination() const {
  return *bstrdestination_;
}
inline void CustROrder_ser::set_bstrdestination(const ::std::string& value) {
  set_has_bstrdestination();
  if (bstrdestination_ == &::google::protobuf::internal::kEmptyString) {
    bstrdestination_ = new ::std::string;
  }
  bstrdestination_->assign(value);
}
inline void CustROrder_ser::set_bstrdestination(const char* value) {
  set_has_bstrdestination();
  if (bstrdestination_ == &::google::protobuf::internal::kEmptyString) {
    bstrdestination_ = new ::std::string;
  }
  bstrdestination_->assign(value);
}
inline void CustROrder_ser::set_bstrdestination(const char* value, size_t size) {
  set_has_bstrdestination();
  if (bstrdestination_ == &::google::protobuf::internal::kEmptyString) {
    bstrdestination_ = new ::std::string;
  }
  bstrdestination_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_bstrdestination() {
  set_has_bstrdestination();
  if (bstrdestination_ == &::google::protobuf::internal::kEmptyString) {
    bstrdestination_ = new ::std::string;
  }
  return bstrdestination_;
}
inline ::std::string* CustROrder_ser::release_bstrdestination() {
  clear_has_bstrdestination();
  if (bstrdestination_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bstrdestination_;
    bstrdestination_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_bstrdestination(::std::string* bstrdestination) {
  if (bstrdestination_ != &::google::protobuf::internal::kEmptyString) {
    delete bstrdestination_;
  }
  if (bstrdestination) {
    set_has_bstrdestination();
    bstrdestination_ = bstrdestination;
  } else {
    clear_has_bstrdestination();
    bstrdestination_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 nOrderStatus = 3;
inline bool CustROrder_ser::has_norderstatus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CustROrder_ser::set_has_norderstatus() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CustROrder_ser::clear_has_norderstatus() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CustROrder_ser::clear_norderstatus() {
  norderstatus_ = 0;
  clear_has_norderstatus();
}
inline ::google::protobuf::int32 CustROrder_ser::norderstatus() const {
  return norderstatus_;
}
inline void CustROrder_ser::set_norderstatus(::google::protobuf::int32 value) {
  set_has_norderstatus();
  norderstatus_ = value;
}

// optional string bstrSymbol = 4;
inline bool CustROrder_ser::has_bstrsymbol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CustROrder_ser::set_has_bstrsymbol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CustROrder_ser::clear_has_bstrsymbol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CustROrder_ser::clear_bstrsymbol() {
  if (bstrsymbol_ != &::google::protobuf::internal::kEmptyString) {
    bstrsymbol_->clear();
  }
  clear_has_bstrsymbol();
}
inline const ::std::string& CustROrder_ser::bstrsymbol() const {
  return *bstrsymbol_;
}
inline void CustROrder_ser::set_bstrsymbol(const ::std::string& value) {
  set_has_bstrsymbol();
  if (bstrsymbol_ == &::google::protobuf::internal::kEmptyString) {
    bstrsymbol_ = new ::std::string;
  }
  bstrsymbol_->assign(value);
}
inline void CustROrder_ser::set_bstrsymbol(const char* value) {
  set_has_bstrsymbol();
  if (bstrsymbol_ == &::google::protobuf::internal::kEmptyString) {
    bstrsymbol_ = new ::std::string;
  }
  bstrsymbol_->assign(value);
}
inline void CustROrder_ser::set_bstrsymbol(const char* value, size_t size) {
  set_has_bstrsymbol();
  if (bstrsymbol_ == &::google::protobuf::internal::kEmptyString) {
    bstrsymbol_ = new ::std::string;
  }
  bstrsymbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_bstrsymbol() {
  set_has_bstrsymbol();
  if (bstrsymbol_ == &::google::protobuf::internal::kEmptyString) {
    bstrsymbol_ = new ::std::string;
  }
  return bstrsymbol_;
}
inline ::std::string* CustROrder_ser::release_bstrsymbol() {
  clear_has_bstrsymbol();
  if (bstrsymbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bstrsymbol_;
    bstrsymbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_bstrsymbol(::std::string* bstrsymbol) {
  if (bstrsymbol_ != &::google::protobuf::internal::kEmptyString) {
    delete bstrsymbol_;
  }
  if (bstrsymbol) {
    set_has_bstrsymbol();
    bstrsymbol_ = bstrsymbol;
  } else {
    clear_has_bstrsymbol();
    bstrsymbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bstrClOrderId = 5;
inline bool CustROrder_ser::has_bstrclorderid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CustROrder_ser::set_has_bstrclorderid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CustROrder_ser::clear_has_bstrclorderid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CustROrder_ser::clear_bstrclorderid() {
  if (bstrclorderid_ != &::google::protobuf::internal::kEmptyString) {
    bstrclorderid_->clear();
  }
  clear_has_bstrclorderid();
}
inline const ::std::string& CustROrder_ser::bstrclorderid() const {
  return *bstrclorderid_;
}
inline void CustROrder_ser::set_bstrclorderid(const ::std::string& value) {
  set_has_bstrclorderid();
  if (bstrclorderid_ == &::google::protobuf::internal::kEmptyString) {
    bstrclorderid_ = new ::std::string;
  }
  bstrclorderid_->assign(value);
}
inline void CustROrder_ser::set_bstrclorderid(const char* value) {
  set_has_bstrclorderid();
  if (bstrclorderid_ == &::google::protobuf::internal::kEmptyString) {
    bstrclorderid_ = new ::std::string;
  }
  bstrclorderid_->assign(value);
}
inline void CustROrder_ser::set_bstrclorderid(const char* value, size_t size) {
  set_has_bstrclorderid();
  if (bstrclorderid_ == &::google::protobuf::internal::kEmptyString) {
    bstrclorderid_ = new ::std::string;
  }
  bstrclorderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_bstrclorderid() {
  set_has_bstrclorderid();
  if (bstrclorderid_ == &::google::protobuf::internal::kEmptyString) {
    bstrclorderid_ = new ::std::string;
  }
  return bstrclorderid_;
}
inline ::std::string* CustROrder_ser::release_bstrclorderid() {
  clear_has_bstrclorderid();
  if (bstrclorderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bstrclorderid_;
    bstrclorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_bstrclorderid(::std::string* bstrclorderid) {
  if (bstrclorderid_ != &::google::protobuf::internal::kEmptyString) {
    delete bstrclorderid_;
  }
  if (bstrclorderid) {
    set_has_bstrclorderid();
    bstrclorderid_ = bstrclorderid;
  } else {
    clear_has_bstrclorderid();
    bstrclorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bstrAction = 6;
inline bool CustROrder_ser::has_bstraction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CustROrder_ser::set_has_bstraction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CustROrder_ser::clear_has_bstraction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CustROrder_ser::clear_bstraction() {
  if (bstraction_ != &::google::protobuf::internal::kEmptyString) {
    bstraction_->clear();
  }
  clear_has_bstraction();
}
inline const ::std::string& CustROrder_ser::bstraction() const {
  return *bstraction_;
}
inline void CustROrder_ser::set_bstraction(const ::std::string& value) {
  set_has_bstraction();
  if (bstraction_ == &::google::protobuf::internal::kEmptyString) {
    bstraction_ = new ::std::string;
  }
  bstraction_->assign(value);
}
inline void CustROrder_ser::set_bstraction(const char* value) {
  set_has_bstraction();
  if (bstraction_ == &::google::protobuf::internal::kEmptyString) {
    bstraction_ = new ::std::string;
  }
  bstraction_->assign(value);
}
inline void CustROrder_ser::set_bstraction(const char* value, size_t size) {
  set_has_bstraction();
  if (bstraction_ == &::google::protobuf::internal::kEmptyString) {
    bstraction_ = new ::std::string;
  }
  bstraction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_bstraction() {
  set_has_bstraction();
  if (bstraction_ == &::google::protobuf::internal::kEmptyString) {
    bstraction_ = new ::std::string;
  }
  return bstraction_;
}
inline ::std::string* CustROrder_ser::release_bstraction() {
  clear_has_bstraction();
  if (bstraction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bstraction_;
    bstraction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_bstraction(::std::string* bstraction) {
  if (bstraction_ != &::google::protobuf::internal::kEmptyString) {
    delete bstraction_;
  }
  if (bstraction) {
    set_has_bstraction();
    bstraction_ = bstraction;
  } else {
    clear_has_bstraction();
    bstraction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string Side = 7;
inline bool CustROrder_ser::has_side() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CustROrder_ser::set_has_side() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CustROrder_ser::clear_has_side() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CustROrder_ser::clear_side() {
  if (side_ != &::google::protobuf::internal::kEmptyString) {
    side_->clear();
  }
  clear_has_side();
}
inline const ::std::string& CustROrder_ser::side() const {
  return *side_;
}
inline void CustROrder_ser::set_side(const ::std::string& value) {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  side_->assign(value);
}
inline void CustROrder_ser::set_side(const char* value) {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  side_->assign(value);
}
inline void CustROrder_ser::set_side(const char* value, size_t size) {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  side_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_side() {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  return side_;
}
inline ::std::string* CustROrder_ser::release_side() {
  clear_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = side_;
    side_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_side(::std::string* side) {
  if (side_ != &::google::protobuf::internal::kEmptyString) {
    delete side_;
  }
  if (side) {
    set_has_side();
    side_ = side;
  } else {
    clear_has_side();
    side_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 nQuantity = 8;
inline bool CustROrder_ser::has_nquantity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CustROrder_ser::set_has_nquantity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CustROrder_ser::clear_has_nquantity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CustROrder_ser::clear_nquantity() {
  nquantity_ = 0;
  clear_has_nquantity();
}
inline ::google::protobuf::int32 CustROrder_ser::nquantity() const {
  return nquantity_;
}
inline void CustROrder_ser::set_nquantity(::google::protobuf::int32 value) {
  set_has_nquantity();
  nquantity_ = value;
}

// optional int32 nLvsQuantity = 9;
inline bool CustROrder_ser::has_nlvsquantity() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CustROrder_ser::set_has_nlvsquantity() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CustROrder_ser::clear_has_nlvsquantity() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CustROrder_ser::clear_nlvsquantity() {
  nlvsquantity_ = 0;
  clear_has_nlvsquantity();
}
inline ::google::protobuf::int32 CustROrder_ser::nlvsquantity() const {
  return nlvsquantity_;
}
inline void CustROrder_ser::set_nlvsquantity(::google::protobuf::int32 value) {
  set_has_nlvsquantity();
  nlvsquantity_ = value;
}

// optional string bstrLogMessage = 10;
inline bool CustROrder_ser::has_bstrlogmessage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CustROrder_ser::set_has_bstrlogmessage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CustROrder_ser::clear_has_bstrlogmessage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CustROrder_ser::clear_bstrlogmessage() {
  if (bstrlogmessage_ != &::google::protobuf::internal::kEmptyString) {
    bstrlogmessage_->clear();
  }
  clear_has_bstrlogmessage();
}
inline const ::std::string& CustROrder_ser::bstrlogmessage() const {
  return *bstrlogmessage_;
}
inline void CustROrder_ser::set_bstrlogmessage(const ::std::string& value) {
  set_has_bstrlogmessage();
  if (bstrlogmessage_ == &::google::protobuf::internal::kEmptyString) {
    bstrlogmessage_ = new ::std::string;
  }
  bstrlogmessage_->assign(value);
}
inline void CustROrder_ser::set_bstrlogmessage(const char* value) {
  set_has_bstrlogmessage();
  if (bstrlogmessage_ == &::google::protobuf::internal::kEmptyString) {
    bstrlogmessage_ = new ::std::string;
  }
  bstrlogmessage_->assign(value);
}
inline void CustROrder_ser::set_bstrlogmessage(const char* value, size_t size) {
  set_has_bstrlogmessage();
  if (bstrlogmessage_ == &::google::protobuf::internal::kEmptyString) {
    bstrlogmessage_ = new ::std::string;
  }
  bstrlogmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_bstrlogmessage() {
  set_has_bstrlogmessage();
  if (bstrlogmessage_ == &::google::protobuf::internal::kEmptyString) {
    bstrlogmessage_ = new ::std::string;
  }
  return bstrlogmessage_;
}
inline ::std::string* CustROrder_ser::release_bstrlogmessage() {
  clear_has_bstrlogmessage();
  if (bstrlogmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bstrlogmessage_;
    bstrlogmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_bstrlogmessage(::std::string* bstrlogmessage) {
  if (bstrlogmessage_ != &::google::protobuf::internal::kEmptyString) {
    delete bstrlogmessage_;
  }
  if (bstrlogmessage) {
    set_has_bstrlogmessage();
    bstrlogmessage_ = bstrlogmessage;
  } else {
    clear_has_bstrlogmessage();
    bstrlogmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float LmtPrice = 11;
inline bool CustROrder_ser::has_lmtprice() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CustROrder_ser::set_has_lmtprice() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CustROrder_ser::clear_has_lmtprice() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CustROrder_ser::clear_lmtprice() {
  lmtprice_ = 0;
  clear_has_lmtprice();
}
inline float CustROrder_ser::lmtprice() const {
  return lmtprice_;
}
inline void CustROrder_ser::set_lmtprice(float value) {
  set_has_lmtprice();
  lmtprice_ = value;
}

// optional string bstrUser = 12;
inline bool CustROrder_ser::has_bstruser() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CustROrder_ser::set_has_bstruser() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CustROrder_ser::clear_has_bstruser() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CustROrder_ser::clear_bstruser() {
  if (bstruser_ != &::google::protobuf::internal::kEmptyString) {
    bstruser_->clear();
  }
  clear_has_bstruser();
}
inline const ::std::string& CustROrder_ser::bstruser() const {
  return *bstruser_;
}
inline void CustROrder_ser::set_bstruser(const ::std::string& value) {
  set_has_bstruser();
  if (bstruser_ == &::google::protobuf::internal::kEmptyString) {
    bstruser_ = new ::std::string;
  }
  bstruser_->assign(value);
}
inline void CustROrder_ser::set_bstruser(const char* value) {
  set_has_bstruser();
  if (bstruser_ == &::google::protobuf::internal::kEmptyString) {
    bstruser_ = new ::std::string;
  }
  bstruser_->assign(value);
}
inline void CustROrder_ser::set_bstruser(const char* value, size_t size) {
  set_has_bstruser();
  if (bstruser_ == &::google::protobuf::internal::kEmptyString) {
    bstruser_ = new ::std::string;
  }
  bstruser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_bstruser() {
  set_has_bstruser();
  if (bstruser_ == &::google::protobuf::internal::kEmptyString) {
    bstruser_ = new ::std::string;
  }
  return bstruser_;
}
inline ::std::string* CustROrder_ser::release_bstruser() {
  clear_has_bstruser();
  if (bstruser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bstruser_;
    bstruser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_bstruser(::std::string* bstruser) {
  if (bstruser_ != &::google::protobuf::internal::kEmptyString) {
    delete bstruser_;
  }
  if (bstruser) {
    set_has_bstruser();
    bstruser_ = bstruser;
  } else {
    clear_has_bstruser();
    bstruser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 TotalExecutedQty = 13;
inline bool CustROrder_ser::has_totalexecutedqty() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CustROrder_ser::set_has_totalexecutedqty() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CustROrder_ser::clear_has_totalexecutedqty() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CustROrder_ser::clear_totalexecutedqty() {
  totalexecutedqty_ = 0;
  clear_has_totalexecutedqty();
}
inline ::google::protobuf::int32 CustROrder_ser::totalexecutedqty() const {
  return totalexecutedqty_;
}
inline void CustROrder_ser::set_totalexecutedqty(::google::protobuf::int32 value) {
  set_has_totalexecutedqty();
  totalexecutedqty_ = value;
}

// optional int32 ExecutedQty = 14;
inline bool CustROrder_ser::has_executedqty() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CustROrder_ser::set_has_executedqty() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CustROrder_ser::clear_has_executedqty() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CustROrder_ser::clear_executedqty() {
  executedqty_ = 0;
  clear_has_executedqty();
}
inline ::google::protobuf::int32 CustROrder_ser::executedqty() const {
  return executedqty_;
}
inline void CustROrder_ser::set_executedqty(::google::protobuf::int32 value) {
  set_has_executedqty();
  executedqty_ = value;
}

// optional string cust_cancelOrderID = 15;
inline bool CustROrder_ser::has_cust_cancelorderid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CustROrder_ser::set_has_cust_cancelorderid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CustROrder_ser::clear_has_cust_cancelorderid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CustROrder_ser::clear_cust_cancelorderid() {
  if (cust_cancelorderid_ != &::google::protobuf::internal::kEmptyString) {
    cust_cancelorderid_->clear();
  }
  clear_has_cust_cancelorderid();
}
inline const ::std::string& CustROrder_ser::cust_cancelorderid() const {
  return *cust_cancelorderid_;
}
inline void CustROrder_ser::set_cust_cancelorderid(const ::std::string& value) {
  set_has_cust_cancelorderid();
  if (cust_cancelorderid_ == &::google::protobuf::internal::kEmptyString) {
    cust_cancelorderid_ = new ::std::string;
  }
  cust_cancelorderid_->assign(value);
}
inline void CustROrder_ser::set_cust_cancelorderid(const char* value) {
  set_has_cust_cancelorderid();
  if (cust_cancelorderid_ == &::google::protobuf::internal::kEmptyString) {
    cust_cancelorderid_ = new ::std::string;
  }
  cust_cancelorderid_->assign(value);
}
inline void CustROrder_ser::set_cust_cancelorderid(const char* value, size_t size) {
  set_has_cust_cancelorderid();
  if (cust_cancelorderid_ == &::google::protobuf::internal::kEmptyString) {
    cust_cancelorderid_ = new ::std::string;
  }
  cust_cancelorderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_cust_cancelorderid() {
  set_has_cust_cancelorderid();
  if (cust_cancelorderid_ == &::google::protobuf::internal::kEmptyString) {
    cust_cancelorderid_ = new ::std::string;
  }
  return cust_cancelorderid_;
}
inline ::std::string* CustROrder_ser::release_cust_cancelorderid() {
  clear_has_cust_cancelorderid();
  if (cust_cancelorderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cust_cancelorderid_;
    cust_cancelorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_cust_cancelorderid(::std::string* cust_cancelorderid) {
  if (cust_cancelorderid_ != &::google::protobuf::internal::kEmptyString) {
    delete cust_cancelorderid_;
  }
  if (cust_cancelorderid) {
    set_has_cust_cancelorderid();
    cust_cancelorderid_ = cust_cancelorderid;
  } else {
    clear_has_cust_cancelorderid();
    cust_cancelorderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cust_orderCategory = 16;
inline bool CustROrder_ser::has_cust_ordercategory() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CustROrder_ser::set_has_cust_ordercategory() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CustROrder_ser::clear_has_cust_ordercategory() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CustROrder_ser::clear_cust_ordercategory() {
  if (cust_ordercategory_ != &::google::protobuf::internal::kEmptyString) {
    cust_ordercategory_->clear();
  }
  clear_has_cust_ordercategory();
}
inline const ::std::string& CustROrder_ser::cust_ordercategory() const {
  return *cust_ordercategory_;
}
inline void CustROrder_ser::set_cust_ordercategory(const ::std::string& value) {
  set_has_cust_ordercategory();
  if (cust_ordercategory_ == &::google::protobuf::internal::kEmptyString) {
    cust_ordercategory_ = new ::std::string;
  }
  cust_ordercategory_->assign(value);
}
inline void CustROrder_ser::set_cust_ordercategory(const char* value) {
  set_has_cust_ordercategory();
  if (cust_ordercategory_ == &::google::protobuf::internal::kEmptyString) {
    cust_ordercategory_ = new ::std::string;
  }
  cust_ordercategory_->assign(value);
}
inline void CustROrder_ser::set_cust_ordercategory(const char* value, size_t size) {
  set_has_cust_ordercategory();
  if (cust_ordercategory_ == &::google::protobuf::internal::kEmptyString) {
    cust_ordercategory_ = new ::std::string;
  }
  cust_ordercategory_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_cust_ordercategory() {
  set_has_cust_ordercategory();
  if (cust_ordercategory_ == &::google::protobuf::internal::kEmptyString) {
    cust_ordercategory_ = new ::std::string;
  }
  return cust_ordercategory_;
}
inline ::std::string* CustROrder_ser::release_cust_ordercategory() {
  clear_has_cust_ordercategory();
  if (cust_ordercategory_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cust_ordercategory_;
    cust_ordercategory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_cust_ordercategory(::std::string* cust_ordercategory) {
  if (cust_ordercategory_ != &::google::protobuf::internal::kEmptyString) {
    delete cust_ordercategory_;
  }
  if (cust_ordercategory) {
    set_has_cust_ordercategory();
    cust_ordercategory_ = cust_ordercategory;
  } else {
    clear_has_cust_ordercategory();
    cust_ordercategory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Serializable.CustROrder_ser.EPriceType PriceType = 17;
inline bool CustROrder_ser::has_pricetype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CustROrder_ser::set_has_pricetype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CustROrder_ser::clear_has_pricetype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CustROrder_ser::clear_pricetype() {
  pricetype_ = 0;
  clear_has_pricetype();
}
inline ::Serializable::CustROrder_ser_EPriceType CustROrder_ser::pricetype() const {
  return static_cast< ::Serializable::CustROrder_ser_EPriceType >(pricetype_);
}
inline void CustROrder_ser::set_pricetype(::Serializable::CustROrder_ser_EPriceType value) {
  assert(::Serializable::CustROrder_ser_EPriceType_IsValid(value));
  set_has_pricetype();
  pricetype_ = value;
}

// optional string TIF = 18;
inline bool CustROrder_ser::has_tif() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CustROrder_ser::set_has_tif() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CustROrder_ser::clear_has_tif() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CustROrder_ser::clear_tif() {
  if (tif_ != &::google::protobuf::internal::kEmptyString) {
    tif_->clear();
  }
  clear_has_tif();
}
inline const ::std::string& CustROrder_ser::tif() const {
  return *tif_;
}
inline void CustROrder_ser::set_tif(const ::std::string& value) {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  tif_->assign(value);
}
inline void CustROrder_ser::set_tif(const char* value) {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  tif_->assign(value);
}
inline void CustROrder_ser::set_tif(const char* value, size_t size) {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  tif_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_tif() {
  set_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    tif_ = new ::std::string;
  }
  return tif_;
}
inline ::std::string* CustROrder_ser::release_tif() {
  clear_has_tif();
  if (tif_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tif_;
    tif_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_tif(::std::string* tif) {
  if (tif_ != &::google::protobuf::internal::kEmptyString) {
    delete tif_;
  }
  if (tif) {
    set_has_tif();
    tif_ = tif;
  } else {
    clear_has_tif();
    tif_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string DateTime = 19;
inline bool CustROrder_ser::has_datetime() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CustROrder_ser::set_has_datetime() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CustROrder_ser::clear_has_datetime() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CustROrder_ser::clear_datetime() {
  if (datetime_ != &::google::protobuf::internal::kEmptyString) {
    datetime_->clear();
  }
  clear_has_datetime();
}
inline const ::std::string& CustROrder_ser::datetime() const {
  return *datetime_;
}
inline void CustROrder_ser::set_datetime(const ::std::string& value) {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  datetime_->assign(value);
}
inline void CustROrder_ser::set_datetime(const char* value) {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  datetime_->assign(value);
}
inline void CustROrder_ser::set_datetime(const char* value, size_t size) {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_datetime() {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  return datetime_;
}
inline ::std::string* CustROrder_ser::release_datetime() {
  clear_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datetime_;
    datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_datetime(::std::string* datetime) {
  if (datetime_ != &::google::protobuf::internal::kEmptyString) {
    delete datetime_;
  }
  if (datetime) {
    set_has_datetime();
    datetime_ = datetime;
  } else {
    clear_has_datetime();
    datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strategy = 20;
inline bool CustROrder_ser::has_strategy() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CustROrder_ser::set_has_strategy() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CustROrder_ser::clear_has_strategy() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CustROrder_ser::clear_strategy() {
  if (strategy_ != &::google::protobuf::internal::kEmptyString) {
    strategy_->clear();
  }
  clear_has_strategy();
}
inline const ::std::string& CustROrder_ser::strategy() const {
  return *strategy_;
}
inline void CustROrder_ser::set_strategy(const ::std::string& value) {
  set_has_strategy();
  if (strategy_ == &::google::protobuf::internal::kEmptyString) {
    strategy_ = new ::std::string;
  }
  strategy_->assign(value);
}
inline void CustROrder_ser::set_strategy(const char* value) {
  set_has_strategy();
  if (strategy_ == &::google::protobuf::internal::kEmptyString) {
    strategy_ = new ::std::string;
  }
  strategy_->assign(value);
}
inline void CustROrder_ser::set_strategy(const char* value, size_t size) {
  set_has_strategy();
  if (strategy_ == &::google::protobuf::internal::kEmptyString) {
    strategy_ = new ::std::string;
  }
  strategy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_strategy() {
  set_has_strategy();
  if (strategy_ == &::google::protobuf::internal::kEmptyString) {
    strategy_ = new ::std::string;
  }
  return strategy_;
}
inline ::std::string* CustROrder_ser::release_strategy() {
  clear_has_strategy();
  if (strategy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strategy_;
    strategy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_strategy(::std::string* strategy) {
  if (strategy_ != &::google::protobuf::internal::kEmptyString) {
    delete strategy_;
  }
  if (strategy) {
    set_has_strategy();
    strategy_ = strategy;
  } else {
    clear_has_strategy();
    strategy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string maturity = 22;
inline bool CustROrder_ser::has_maturity() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CustROrder_ser::set_has_maturity() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CustROrder_ser::clear_has_maturity() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CustROrder_ser::clear_maturity() {
  if (maturity_ != &::google::protobuf::internal::kEmptyString) {
    maturity_->clear();
  }
  clear_has_maturity();
}
inline const ::std::string& CustROrder_ser::maturity() const {
  return *maturity_;
}
inline void CustROrder_ser::set_maturity(const ::std::string& value) {
  set_has_maturity();
  if (maturity_ == &::google::protobuf::internal::kEmptyString) {
    maturity_ = new ::std::string;
  }
  maturity_->assign(value);
}
inline void CustROrder_ser::set_maturity(const char* value) {
  set_has_maturity();
  if (maturity_ == &::google::protobuf::internal::kEmptyString) {
    maturity_ = new ::std::string;
  }
  maturity_->assign(value);
}
inline void CustROrder_ser::set_maturity(const char* value, size_t size) {
  set_has_maturity();
  if (maturity_ == &::google::protobuf::internal::kEmptyString) {
    maturity_ = new ::std::string;
  }
  maturity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_maturity() {
  set_has_maturity();
  if (maturity_ == &::google::protobuf::internal::kEmptyString) {
    maturity_ = new ::std::string;
  }
  return maturity_;
}
inline ::std::string* CustROrder_ser::release_maturity() {
  clear_has_maturity();
  if (maturity_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = maturity_;
    maturity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_maturity(::std::string* maturity) {
  if (maturity_ != &::google::protobuf::internal::kEmptyString) {
    delete maturity_;
  }
  if (maturity) {
    set_has_maturity();
    maturity_ = maturity;
  } else {
    clear_has_maturity();
    maturity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string putcall = 23;
inline bool CustROrder_ser::has_putcall() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CustROrder_ser::set_has_putcall() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CustROrder_ser::clear_has_putcall() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CustROrder_ser::clear_putcall() {
  if (putcall_ != &::google::protobuf::internal::kEmptyString) {
    putcall_->clear();
  }
  clear_has_putcall();
}
inline const ::std::string& CustROrder_ser::putcall() const {
  return *putcall_;
}
inline void CustROrder_ser::set_putcall(const ::std::string& value) {
  set_has_putcall();
  if (putcall_ == &::google::protobuf::internal::kEmptyString) {
    putcall_ = new ::std::string;
  }
  putcall_->assign(value);
}
inline void CustROrder_ser::set_putcall(const char* value) {
  set_has_putcall();
  if (putcall_ == &::google::protobuf::internal::kEmptyString) {
    putcall_ = new ::std::string;
  }
  putcall_->assign(value);
}
inline void CustROrder_ser::set_putcall(const char* value, size_t size) {
  set_has_putcall();
  if (putcall_ == &::google::protobuf::internal::kEmptyString) {
    putcall_ = new ::std::string;
  }
  putcall_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_putcall() {
  set_has_putcall();
  if (putcall_ == &::google::protobuf::internal::kEmptyString) {
    putcall_ = new ::std::string;
  }
  return putcall_;
}
inline ::std::string* CustROrder_ser::release_putcall() {
  clear_has_putcall();
  if (putcall_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = putcall_;
    putcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_putcall(::std::string* putcall) {
  if (putcall_ != &::google::protobuf::internal::kEmptyString) {
    delete putcall_;
  }
  if (putcall) {
    set_has_putcall();
    putcall_ = putcall;
  } else {
    clear_has_putcall();
    putcall_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string instrument = 24;
inline bool CustROrder_ser::has_instrument() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CustROrder_ser::set_has_instrument() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CustROrder_ser::clear_has_instrument() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CustROrder_ser::clear_instrument() {
  if (instrument_ != &::google::protobuf::internal::kEmptyString) {
    instrument_->clear();
  }
  clear_has_instrument();
}
inline const ::std::string& CustROrder_ser::instrument() const {
  return *instrument_;
}
inline void CustROrder_ser::set_instrument(const ::std::string& value) {
  set_has_instrument();
  if (instrument_ == &::google::protobuf::internal::kEmptyString) {
    instrument_ = new ::std::string;
  }
  instrument_->assign(value);
}
inline void CustROrder_ser::set_instrument(const char* value) {
  set_has_instrument();
  if (instrument_ == &::google::protobuf::internal::kEmptyString) {
    instrument_ = new ::std::string;
  }
  instrument_->assign(value);
}
inline void CustROrder_ser::set_instrument(const char* value, size_t size) {
  set_has_instrument();
  if (instrument_ == &::google::protobuf::internal::kEmptyString) {
    instrument_ = new ::std::string;
  }
  instrument_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == &::google::protobuf::internal::kEmptyString) {
    instrument_ = new ::std::string;
  }
  return instrument_;
}
inline ::std::string* CustROrder_ser::release_instrument() {
  clear_has_instrument();
  if (instrument_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_;
    instrument_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_instrument(::std::string* instrument) {
  if (instrument_ != &::google::protobuf::internal::kEmptyString) {
    delete instrument_;
  }
  if (instrument) {
    set_has_instrument();
    instrument_ = instrument;
  } else {
    clear_has_instrument();
    instrument_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float strikeprice = 25;
inline bool CustROrder_ser::has_strikeprice() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CustROrder_ser::set_has_strikeprice() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CustROrder_ser::clear_has_strikeprice() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CustROrder_ser::clear_strikeprice() {
  strikeprice_ = 0;
  clear_has_strikeprice();
}
inline float CustROrder_ser::strikeprice() const {
  return strikeprice_;
}
inline void CustROrder_ser::set_strikeprice(float value) {
  set_has_strikeprice();
  strikeprice_ = value;
}

// optional string underlying = 26;
inline bool CustROrder_ser::has_underlying() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CustROrder_ser::set_has_underlying() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CustROrder_ser::clear_has_underlying() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CustROrder_ser::clear_underlying() {
  if (underlying_ != &::google::protobuf::internal::kEmptyString) {
    underlying_->clear();
  }
  clear_has_underlying();
}
inline const ::std::string& CustROrder_ser::underlying() const {
  return *underlying_;
}
inline void CustROrder_ser::set_underlying(const ::std::string& value) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::kEmptyString) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(value);
}
inline void CustROrder_ser::set_underlying(const char* value) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::kEmptyString) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(value);
}
inline void CustROrder_ser::set_underlying(const char* value, size_t size) {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::kEmptyString) {
    underlying_ = new ::std::string;
  }
  underlying_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_underlying() {
  set_has_underlying();
  if (underlying_ == &::google::protobuf::internal::kEmptyString) {
    underlying_ = new ::std::string;
  }
  return underlying_;
}
inline ::std::string* CustROrder_ser::release_underlying() {
  clear_has_underlying();
  if (underlying_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_;
    underlying_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_underlying(::std::string* underlying) {
  if (underlying_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_;
  }
  if (underlying) {
    set_has_underlying();
    underlying_ = underlying;
  } else {
    clear_has_underlying();
    underlying_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nOrderRecordId = 27;
inline bool CustROrder_ser::has_norderrecordid() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CustROrder_ser::set_has_norderrecordid() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CustROrder_ser::clear_has_norderrecordid() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CustROrder_ser::clear_norderrecordid() {
  if (norderrecordid_ != &::google::protobuf::internal::kEmptyString) {
    norderrecordid_->clear();
  }
  clear_has_norderrecordid();
}
inline const ::std::string& CustROrder_ser::norderrecordid() const {
  return *norderrecordid_;
}
inline void CustROrder_ser::set_norderrecordid(const ::std::string& value) {
  set_has_norderrecordid();
  if (norderrecordid_ == &::google::protobuf::internal::kEmptyString) {
    norderrecordid_ = new ::std::string;
  }
  norderrecordid_->assign(value);
}
inline void CustROrder_ser::set_norderrecordid(const char* value) {
  set_has_norderrecordid();
  if (norderrecordid_ == &::google::protobuf::internal::kEmptyString) {
    norderrecordid_ = new ::std::string;
  }
  norderrecordid_->assign(value);
}
inline void CustROrder_ser::set_norderrecordid(const char* value, size_t size) {
  set_has_norderrecordid();
  if (norderrecordid_ == &::google::protobuf::internal::kEmptyString) {
    norderrecordid_ = new ::std::string;
  }
  norderrecordid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CustROrder_ser::mutable_norderrecordid() {
  set_has_norderrecordid();
  if (norderrecordid_ == &::google::protobuf::internal::kEmptyString) {
    norderrecordid_ = new ::std::string;
  }
  return norderrecordid_;
}
inline ::std::string* CustROrder_ser::release_norderrecordid() {
  clear_has_norderrecordid();
  if (norderrecordid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = norderrecordid_;
    norderrecordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CustROrder_ser::set_allocated_norderrecordid(::std::string* norderrecordid) {
  if (norderrecordid_ != &::google::protobuf::internal::kEmptyString) {
    delete norderrecordid_;
  }
  if (norderrecordid) {
    set_has_norderrecordid();
    norderrecordid_ = norderrecordid;
  } else {
    clear_has_norderrecordid();
    norderrecordid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ROrderPosition

// optional int32 position = 1;
inline bool ROrderPosition::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ROrderPosition::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ROrderPosition::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ROrderPosition::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 ROrderPosition::position() const {
  return position_;
}
inline void ROrderPosition::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
}

// optional float execution_price = 2;
inline bool ROrderPosition::has_execution_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ROrderPosition::set_has_execution_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ROrderPosition::clear_has_execution_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ROrderPosition::clear_execution_price() {
  execution_price_ = 0;
  clear_has_execution_price();
}
inline float ROrderPosition::execution_price() const {
  return execution_price_;
}
inline void ROrderPosition::set_execution_price(float value) {
  set_has_execution_price();
  execution_price_ = value;
}

// -------------------------------------------------------------------

// TradeUpdate

// optional string symbol = 1;
inline bool TradeUpdate::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradeUpdate::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradeUpdate::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradeUpdate::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& TradeUpdate::symbol() const {
  return *symbol_;
}
inline void TradeUpdate::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void TradeUpdate::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void TradeUpdate::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeUpdate::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* TradeUpdate::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeUpdate::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string client_id = 2;
inline bool TradeUpdate::has_client_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradeUpdate::set_has_client_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradeUpdate::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradeUpdate::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::kEmptyString) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& TradeUpdate::client_id() const {
  return *client_id_;
}
inline void TradeUpdate::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void TradeUpdate::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
}
inline void TradeUpdate::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeUpdate::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    client_id_ = new ::std::string;
  }
  return client_id_;
}
inline ::std::string* TradeUpdate::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeUpdate::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::kEmptyString) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string side = 3;
inline bool TradeUpdate::has_side() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TradeUpdate::set_has_side() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TradeUpdate::clear_has_side() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TradeUpdate::clear_side() {
  if (side_ != &::google::protobuf::internal::kEmptyString) {
    side_->clear();
  }
  clear_has_side();
}
inline const ::std::string& TradeUpdate::side() const {
  return *side_;
}
inline void TradeUpdate::set_side(const ::std::string& value) {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  side_->assign(value);
}
inline void TradeUpdate::set_side(const char* value) {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  side_->assign(value);
}
inline void TradeUpdate::set_side(const char* value, size_t size) {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  side_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeUpdate::mutable_side() {
  set_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    side_ = new ::std::string;
  }
  return side_;
}
inline ::std::string* TradeUpdate::release_side() {
  clear_has_side();
  if (side_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = side_;
    side_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeUpdate::set_allocated_side(::std::string* side) {
  if (side_ != &::google::protobuf::internal::kEmptyString) {
    delete side_;
  }
  if (side) {
    set_has_side();
    side_ = side;
  } else {
    clear_has_side();
    side_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 volume = 4;
inline bool TradeUpdate::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TradeUpdate::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TradeUpdate::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TradeUpdate::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 TradeUpdate::volume() const {
  return volume_;
}
inline void TradeUpdate::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
}

// optional float exec_price = 5;
inline bool TradeUpdate::has_exec_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TradeUpdate::set_has_exec_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TradeUpdate::clear_has_exec_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TradeUpdate::clear_exec_price() {
  exec_price_ = 0;
  clear_has_exec_price();
}
inline float TradeUpdate::exec_price() const {
  return exec_price_;
}
inline void TradeUpdate::set_exec_price(float value) {
  set_has_exec_price();
  exec_price_ = value;
}

// optional string DateTimetime = 6;
inline bool TradeUpdate::has_datetimetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TradeUpdate::set_has_datetimetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TradeUpdate::clear_has_datetimetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TradeUpdate::clear_datetimetime() {
  if (datetimetime_ != &::google::protobuf::internal::kEmptyString) {
    datetimetime_->clear();
  }
  clear_has_datetimetime();
}
inline const ::std::string& TradeUpdate::datetimetime() const {
  return *datetimetime_;
}
inline void TradeUpdate::set_datetimetime(const ::std::string& value) {
  set_has_datetimetime();
  if (datetimetime_ == &::google::protobuf::internal::kEmptyString) {
    datetimetime_ = new ::std::string;
  }
  datetimetime_->assign(value);
}
inline void TradeUpdate::set_datetimetime(const char* value) {
  set_has_datetimetime();
  if (datetimetime_ == &::google::protobuf::internal::kEmptyString) {
    datetimetime_ = new ::std::string;
  }
  datetimetime_->assign(value);
}
inline void TradeUpdate::set_datetimetime(const char* value, size_t size) {
  set_has_datetimetime();
  if (datetimetime_ == &::google::protobuf::internal::kEmptyString) {
    datetimetime_ = new ::std::string;
  }
  datetimetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeUpdate::mutable_datetimetime() {
  set_has_datetimetime();
  if (datetimetime_ == &::google::protobuf::internal::kEmptyString) {
    datetimetime_ = new ::std::string;
  }
  return datetimetime_;
}
inline ::std::string* TradeUpdate::release_datetimetime() {
  clear_has_datetimetime();
  if (datetimetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datetimetime_;
    datetimetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TradeUpdate::set_allocated_datetimetime(::std::string* datetimetime) {
  if (datetimetime_ != &::google::protobuf::internal::kEmptyString) {
    delete datetimetime_;
  }
  if (datetimetime) {
    set_has_datetimetime();
    datetimetime_ = datetimetime;
  } else {
    clear_has_datetimetime();
    datetimetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RUpdatePacket

// optional .Serializable.CustROrder_ser custOrd = 1;
inline bool RUpdatePacket::has_custord() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RUpdatePacket::set_has_custord() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RUpdatePacket::clear_has_custord() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RUpdatePacket::clear_custord() {
  if (custord_ != NULL) custord_->::Serializable::CustROrder_ser::Clear();
  clear_has_custord();
}
inline const ::Serializable::CustROrder_ser& RUpdatePacket::custord() const {
  return custord_ != NULL ? *custord_ : *default_instance_->custord_;
}
inline ::Serializable::CustROrder_ser* RUpdatePacket::mutable_custord() {
  set_has_custord();
  if (custord_ == NULL) custord_ = new ::Serializable::CustROrder_ser;
  return custord_;
}
inline ::Serializable::CustROrder_ser* RUpdatePacket::release_custord() {
  clear_has_custord();
  ::Serializable::CustROrder_ser* temp = custord_;
  custord_ = NULL;
  return temp;
}
inline void RUpdatePacket::set_allocated_custord(::Serializable::CustROrder_ser* custord) {
  delete custord_;
  custord_ = custord;
  if (custord) {
    set_has_custord();
  } else {
    clear_has_custord();
  }
}

// optional .Serializable.ROrderPosition pos = 2;
inline bool RUpdatePacket::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RUpdatePacket::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RUpdatePacket::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RUpdatePacket::clear_pos() {
  if (pos_ != NULL) pos_->::Serializable::ROrderPosition::Clear();
  clear_has_pos();
}
inline const ::Serializable::ROrderPosition& RUpdatePacket::pos() const {
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::Serializable::ROrderPosition* RUpdatePacket::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) pos_ = new ::Serializable::ROrderPosition;
  return pos_;
}
inline ::Serializable::ROrderPosition* RUpdatePacket::release_pos() {
  clear_has_pos();
  ::Serializable::ROrderPosition* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void RUpdatePacket::set_allocated_pos(::Serializable::ROrderPosition* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
}

// optional .Serializable.TradeUpdate tupdate = 3;
inline bool RUpdatePacket::has_tupdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RUpdatePacket::set_has_tupdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RUpdatePacket::clear_has_tupdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RUpdatePacket::clear_tupdate() {
  if (tupdate_ != NULL) tupdate_->::Serializable::TradeUpdate::Clear();
  clear_has_tupdate();
}
inline const ::Serializable::TradeUpdate& RUpdatePacket::tupdate() const {
  return tupdate_ != NULL ? *tupdate_ : *default_instance_->tupdate_;
}
inline ::Serializable::TradeUpdate* RUpdatePacket::mutable_tupdate() {
  set_has_tupdate();
  if (tupdate_ == NULL) tupdate_ = new ::Serializable::TradeUpdate;
  return tupdate_;
}
inline ::Serializable::TradeUpdate* RUpdatePacket::release_tupdate() {
  clear_has_tupdate();
  ::Serializable::TradeUpdate* temp = tupdate_;
  tupdate_ = NULL;
  return temp;
}
inline void RUpdatePacket::set_allocated_tupdate(::Serializable::TradeUpdate* tupdate) {
  delete tupdate_;
  tupdate_ = tupdate;
  if (tupdate) {
    set_has_tupdate();
  } else {
    clear_has_tupdate();
  }
}

// -------------------------------------------------------------------

// ExtraRFields

// optional string FormID = 1;
inline bool ExtraRFields::has_formid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtraRFields::set_has_formid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtraRFields::clear_has_formid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtraRFields::clear_formid() {
  if (formid_ != &::google::protobuf::internal::kEmptyString) {
    formid_->clear();
  }
  clear_has_formid();
}
inline const ::std::string& ExtraRFields::formid() const {
  return *formid_;
}
inline void ExtraRFields::set_formid(const ::std::string& value) {
  set_has_formid();
  if (formid_ == &::google::protobuf::internal::kEmptyString) {
    formid_ = new ::std::string;
  }
  formid_->assign(value);
}
inline void ExtraRFields::set_formid(const char* value) {
  set_has_formid();
  if (formid_ == &::google::protobuf::internal::kEmptyString) {
    formid_ = new ::std::string;
  }
  formid_->assign(value);
}
inline void ExtraRFields::set_formid(const char* value, size_t size) {
  set_has_formid();
  if (formid_ == &::google::protobuf::internal::kEmptyString) {
    formid_ = new ::std::string;
  }
  formid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtraRFields::mutable_formid() {
  set_has_formid();
  if (formid_ == &::google::protobuf::internal::kEmptyString) {
    formid_ = new ::std::string;
  }
  return formid_;
}
inline ::std::string* ExtraRFields::release_formid() {
  clear_has_formid();
  if (formid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = formid_;
    formid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExtraRFields::set_allocated_formid(::std::string* formid) {
  if (formid_ != &::google::protobuf::internal::kEmptyString) {
    delete formid_;
  }
  if (formid) {
    set_has_formid();
    formid_ = formid;
  } else {
    clear_has_formid();
    formid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OrderType = 2;
inline bool ExtraRFields::has_ordertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtraRFields::set_has_ordertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtraRFields::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtraRFields::clear_ordertype() {
  if (ordertype_ != &::google::protobuf::internal::kEmptyString) {
    ordertype_->clear();
  }
  clear_has_ordertype();
}
inline const ::std::string& ExtraRFields::ordertype() const {
  return *ordertype_;
}
inline void ExtraRFields::set_ordertype(const ::std::string& value) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::kEmptyString) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(value);
}
inline void ExtraRFields::set_ordertype(const char* value) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::kEmptyString) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(value);
}
inline void ExtraRFields::set_ordertype(const char* value, size_t size) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::kEmptyString) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtraRFields::mutable_ordertype() {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::kEmptyString) {
    ordertype_ = new ::std::string;
  }
  return ordertype_;
}
inline ::std::string* ExtraRFields::release_ordertype() {
  clear_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordertype_;
    ordertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExtraRFields::set_allocated_ordertype(::std::string* ordertype) {
  if (ordertype_ != &::google::protobuf::internal::kEmptyString) {
    delete ordertype_;
  }
  if (ordertype) {
    set_has_ordertype();
    ordertype_ = ordertype;
  } else {
    clear_has_ordertype();
    ordertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Serializable

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Serializable::CustROrder_ser_EPriceType>() {
  return ::Serializable::CustROrder_ser_EPriceType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rtypes_2eproto__INCLUDED
